

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Qv_X4g7xgX6YzYomj9z_NyYeY4LPrND_
"""

import pandas as pd
import numpy as np


# Load the dataset
# Ensure 'Dataset .csv' is uploaded to your Colab environment
df = pd.read_csv('/content/Dataset .csv')

print("Data Loaded Successfully!")
print(f"Rows: {df.shape[0]}, Columns: {df.shape[1]}")
display(df.head(3))

"""# Level 1

Task 1: Data Exploration and Preprocessing
"""

# Cell 2: Level 1 Task 1
# Libraries needed for this task

import matplotlib.pyplot as plt
import seaborn as sns

# 1. Identify rows and columns
print(f"Dataset contains {df.shape[0]} rows and {df.shape[1]} columns.")

# 2. Check for missing values
print("\nMissing Values per Column:")
print(df.isnull().sum())

# Handle missing values (Example: Drop rows with missing 'Cuisines' as they are few)
df_clean = df.dropna(subset=['Cuisines']).copy()
print(f"\nRows after handling missing values: {df_clean.shape[0]}")

# 3. Data type conversion
# (Checking if 'Votes' or 'Aggregate rating' are numeric - they usually are)
print("\nData Types:")
print(df_clean.dtypes)

# 4. Analyze distribution of 'Aggregate rating'
plt.figure(figsize=(8, 5))
sns.histplot(df_clean['Aggregate rating'], bins=20, kde=True, color='skyblue')
plt.title('Distribution of Aggregate Rating')
plt.xlabel('Rating')
plt.show()

# Check for class imbalance (Target variable counts)
print("\nClass Imbalance Check (Rating counts):")
print(df_clean['Aggregate rating'].value_counts().sort_index())

"""Task 2: Descriptive Analysis"""

# 1. Statistical measures for numerical columns
print("Descriptive Statistics:")
display(df_clean.describe())

# 2. Explore distribution of categorical variables
# Country Code
print("\nUnique Country Codes:", df_clean['Country Code'].nunique())
# City
print("Unique Cities:", df_clean['City'].nunique())
# Cuisines
print("Unique Cuisines:", df_clean['Cuisines'].nunique())

# 3. Top Cuisines and Cities
top_cuisines = df_clean['Cuisines'].value_counts().head(10)
top_cities = df_clean['City'].value_counts().head(10)

# Visualization
fig, axes = plt.subplots(1, 2, figsize=(15, 6))

sns.barplot(x=top_cuisines.values, y=top_cuisines.index, ax=axes[0], palette='viridis')
axes[0].set_title('Top 10 Cuisines')

sns.barplot(x=top_cities.values, y=top_cities.index, ax=axes[1], palette='magma')
axes[1].set_title('Top 10 Cities with most Restaurants')

plt.tight_layout()
plt.show()

"""Task 3: Geospatial Analysis"""

# 1. Visualize locations (Latitude vs Longitude)
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df_clean, x='Longitude', y='Latitude', hue='Aggregate rating', palette='coolwarm', size='Votes', sizes=(10, 200), alpha=0.7)
plt.title('Restaurant Locations & Ratings')
plt.show()

# 2. Distribution across cities
print("\nDistribution of Restaurants across Cities (Top 5):")
print(df_clean['City'].value_counts().head())

# 3. Correlation between location and rating
loc_corr = df_clean[['Latitude', 'Longitude', 'Aggregate rating']].corr()
print("\nCorrelation Matrix:")
display(loc_corr)

"""# Level 2 Tasks

Task 1: Table Booking and Online Delivery
"""

# 1. Percentage of Table Booking and Online Delivery
tbl_book = df_clean['Has Table booking'].value_counts(normalize=True) * 100
online_del = df_clean['Has Online delivery'].value_counts(normalize=True) * 100

print(f"Table Booking: Yes ({tbl_book['Yes']:.2f}%), No ({tbl_book['No']:.2f}%)")
print(f"Online Delivery: Yes ({online_del['Yes']:.2f}%), No ({online_del['No']:.2f}%)")

# 2. Compare average ratings
avg_rating_booking = df_clean.groupby('Has Table booking')['Aggregate rating'].mean()
print("\nAverage Rating (Table Booking vs None):")
print(avg_rating_booking)

# 3. Online Delivery by Price Range
delivery_price = df_clean.groupby('Price range')['Has Online delivery'].value_counts(normalize=True).unstack()
print("\nOnline Delivery availability by Price Range:")
display(delivery_price)

delivery_price.plot(kind='bar', stacked=True, color=['orange', 'green'])
plt.title('Online Delivery by Price Range')
plt.ylabel('Percentage')
plt.show()

"""Task 2: Price Range Analysis"""

# 1. Most common price range
common_price = df_clean['Price range'].mode()[0]
print(f"Most Common Price Range: {common_price}")

# 2. Average rating for each price range
avg_price_rating = df_clean.groupby('Price range')['Aggregate rating'].mean()
print("\nAverage Rating per Price Range:")
print(avg_price_rating)

# 3. Color with highest average rating
# Mapping colors to ratings to see which color group performs best
color_ratings = df_clean.groupby('Rating color')['Aggregate rating'].mean().sort_values(ascending=False)
print("\nAverage Rating per Color Group:")
print(color_ratings)
print(f"\nHighest Rated Color: {color_ratings.idxmax()}")

"""Task 3: Feature Engineering"""

# 1. Extract length of Name and Address
df_clean['Name Length'] = df_clean['Restaurant Name'].apply(len)
df_clean['Address Length'] = df_clean['Address'].apply(len)
print("Features 'Name Length' and 'Address Length' created.")

# 2. Encode categorical variables (Yes/No to 1/0)
df_clean['Has Table booking'] = df_clean['Has Table booking'].map({'Yes': 1, 'No': 0})
df_clean['Has Online delivery'] = df_clean['Has Online delivery'].map({'Yes': 1, 'No': 0})

print("\nEncoded 'Has Table booking' and 'Has Online delivery'.")
display(df_clean[['Restaurant Name', 'Has Table booking', 'Has Online delivery']].head())

"""# Level 3 Tasks

Task 1: Predictive Modeling
"""

# Cell 8: Level 3 Task 1
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, r2_score
import pandas as pd

# Select features and target
features = ['Average Cost for two', 'Has Table booking', 'Has Online delivery', 'Price range', 'Votes']
target = 'Aggregate rating'

X = df_clean[features]
y = df_clean[target]

# 1. Split dataset
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# 2. Build and Evaluate Models
models = {
    "Linear Regression": LinearRegression(),
    "Decision Tree": DecisionTreeRegressor(random_state=42),
    "Random Forest": RandomForestRegressor(n_estimators=50, random_state=42)
}

print("Model Evaluation:")
for name, model in models.items():
    model.fit(X_train, y_train)
    pred = model.predict(X_test)
    mse = mean_squared_error(y_test, pred)
    r2 = r2_score(y_test, pred)
    print(f"{name} -> MSE: {mse:.4f}, R2: {r2:.4f}")

"""Task 2: Customer Preference Analysis"""

# 1. Analyze relationship between Cuisine and Rating
# Extract primary cuisine (first one listed) for simpler analysis
df_clean['Primary Cuisine'] = df_clean['Cuisines'].apply(lambda x: x.split(',')[0])

# Top 15 Cuisines by Average Rating
cuisine_ratings = df_clean.groupby('Primary Cuisine')['Aggregate rating'].mean().sort_values(ascending=False).head(15)

plt.figure(figsize=(12, 6))
sns.barplot(x=cuisine_ratings.values, y=cuisine_ratings.index, palette='cool')
plt.title('Top 15 Cuisines by Average Rating')
plt.xlabel('Average Rating')
plt.show()

# 2. Most popular cuisines (by number of votes)
popular_cuisines = df_clean.groupby('Primary Cuisine')['Votes'].sum().sort_values(ascending=False).head(10)
print("\nMost Popular Cuisines (Total Votes):")
print(popular_cuisines)

"""Task 3: Data Visualization"""

# 1. Distribution of Ratings (Detailed)
plt.figure(figsize=(8, 5))
sns.histplot(df_clean['Aggregate rating'], bins=30, kde=True, color='purple')
plt.title('Distribution of Ratings')
plt.show()

# 2. Compare Average Ratings of Top 10 Cities
top_cities_rating = df_clean.groupby('City')['Aggregate rating'].mean().sort_values(ascending=False).head(10)

plt.figure(figsize=(10, 5))
sns.barplot(x=top_cities_rating.values, y=top_cities_rating.index, palette='autumn')
plt.title('Top 10 Cities by Average Rating')
plt.show()

# 3. Relationship between Votes and Rating
plt.figure(figsize=(8, 6))
sns.scatterplot(x='Votes', y='Aggregate rating', data=df_clean, hue='Price range', palette='viridis', alpha=0.6)
plt.title('Votes vs Aggregate Rating')
plt.xscale('log') # Log scale helps visualization as votes vary widely
plt.show()
